# 数据结构总结

## 基础数据结构

### Array (数组)

- **特点**: 连续内存，固定大小，通过索引访问
- **时间复杂度**:
  - 访问: O(1)
  - 搜索: O(n)
  - 插入: O(n) (需要移动元素)
  - 删除: O(n) (需要移动元素)
- **适用场景**: 需要快速随机访问元素

### Linked List (链表)

- **特点**: 节点通过指针连接，动态大小
- **时间复杂度**:
  - 访问: O(n)
  - 搜索: O(n)
  - 插入: O(1) (已知位置)
  - 删除: O(1) (已知位置)
- **适用场景**: 频繁插入删除，不需要随机访问

### Double Linked List (双链表)

- **特点**: 每个节点有两个指针(前、后)
- **时间复杂度**: 与链表相同，但可以双向遍历
- **优势**: 删除操作更方便，可以从任意方向遍历
- **适用场景**: 需要双向遍历的场景

## 基于基础结构的数据结构

### List (列表/动态数组)

- **底层**: 通常基于动态数组实现
- **时间复杂度**:
  - 访问: O(1)
  - 末尾插入: O(1) 平均
  - 头部插入: O(n)
  - 删除: O(n)
- **适用场景**: 需要动态调整大小的数组

### Stack (栈)

- **特点**: LIFO (后进先出)
- **实现**: 可用数组或链表实现
- **时间复杂度**:
  - push: O(1)
  - pop: O(1)
  - peek: O(1)
- **适用场景**: 函数调用、表达式求值、回溯算法

### Deque (双端队列)

- **特点**: 两端都能插入/删除
- **底层**: 通常用双链表实现
- **时间复杂度**:
  - 两端插入: O(1)
  - 两端删除: O(1)
  - 随机访问: O(n)
- **适用场景**: 需要在两端进行操作，如滑动窗口

### Hash Table (哈希表)

- **特点**: 键值对存储，通过哈希函数映射
- **时间复杂度**:
  - 插入: O(1) 平均
  - 删除: O(1) 平均
  - 查找: O(1) 平均
  - 最坏情况: O(n) (哈希冲突)
- **适用场景**: 快速查找、缓存、数据库索引

### Set (集合)

- **底层**: 通常基于哈希表或红黑树实现
- **时间复杂度**:
  - 插入: O(1) 平均 (哈希) 或 O(log n) (树)
  - 删除: O(1) 平均 (哈希) 或 O(log n) (树)
  - 查找: O(1) 平均 (哈希) 或 O(log n) (树)
- **适用场景**: 去重、集合运算、成员检查

### Heap (堆)

- **特点**: 完全二叉树，父节点 >= 子节点(最大堆)
- **底层**: 通常用数组实现
- **时间复杂度**:
  - 插入: O(log n)
  - 删除最大/最小: O(log n)
  - 查看最大/最小: O(1)
- **适用场景**: 优先队列、堆排序、找第 K 大元素

## 数据结构关系图

```
基础结构:
Array → List (动态数组)
      → Stack (用数组实现)
      → Heap (用数组表示树)

Linked List → Stack (用链表实现)
            → Queue (用链表实现)
            → Deque (可用链表实现)

Double Linked List → Deque 的常见实现

哈希相关:
Hash Table → Set (哈希集合)
          → Dictionary/Map

特殊结构:
Heap → Priority Queue (优先队列)
```

## 选择建议

| 需求          | 推荐数据结构       | 原因             |
| ------------- | ------------------ | ---------------- |
| 随机访问      | Array, List        | O(1)访问时间     |
| 频繁插入/删除 | Linked List, Deque | O(1)插入删除     |
| LIFO 操作     | Stack              | 专门为 LIFO 设计 |
| FIFO 操作     | Queue              | 专门为 FIFO 设计 |
| 两端操作      | Deque              | 两端都是 O(1)    |
| 快速查找      | Hash Table, Set    | 平均 O(1)查找    |
| 排序数据      | Heap               | O(log n)维护顺序 |
| 无重复元素    | Set                | 自动去重         |

## 实际应用例子

### Amazon Locker 系统

```python
# 使用deque管理每种尺寸的可用储物柜
self.available_lockers = {size: deque() for size in Size}

# 分配储物柜: O(1) 从队列头部取出
locker = self.available_lockers[size].popleft()

# 归还储物柜: O(1) 添加到队列尾部
self.available_lockers[locker.get_size()].append(locker)
```

**为什么用 deque？**

- 需要 FIFO 行为（公平分配）
- 两端操作都是 O(1)
- 比 list 的 pop(0)效率高（list.pop(0)是 O(n)）

## 时间复杂度对比表

| 操作 | Array | List | Linked List | Deque | Hash Table | Set     | Heap     |
| ---- | ----- | ---- | ----------- | ----- | ---------- | ------- | -------- |
| 访问 | O(1)  | O(1) | O(n)        | O(n)  | O(1)avg    | O(1)avg | -        |
| 搜索 | O(n)  | O(n) | O(n)        | O(n)  | O(1)avg    | O(1)avg | -        |
| 插入 | O(n)  | O(n) | O(1)        | O(1)  | O(1)avg    | O(1)avg | O(log n) |
| 删除 | O(n)  | O(n) | O(1)        | O(1)  | O(1)avg    | O(1)avg | O(log n) |

## 空间复杂度

- **Array**: O(n)
- **Linked List**: O(n) + 指针开销
- **Hash Table**: O(n) + 哈希表开销
- **Heap**: O(n)

## 总结

选择数据结构时要考虑：

1. **操作频率**: 哪些操作最常用？
2. **时间要求**: 对性能有什么要求？
3. **空间限制**: 内存使用是否有限制？
4. **数据特点**: 数据是否有序、是否有重复？

**记住**: 没有完美的数据结构，只有最适合场景的选择！
